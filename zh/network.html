<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>网络 | Code Docs</title>
    <meta name="description" content="让你的生活变得简单">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="shortcut icon" href="/favicon.png">
    
    <link rel="preload" href="/assets/css/0.styles.7dc41318.css" as="style"><link rel="preload" href="/assets/js/app.f88ae1a5.js" as="script"><link rel="preload" href="/assets/js/2.4be379b3.js" as="script"><link rel="preload" href="/assets/js/29.36c60ab2.js" as="script"><link rel="prefetch" href="/assets/js/10.e0cd67f8.js"><link rel="prefetch" href="/assets/js/11.38fbdb47.js"><link rel="prefetch" href="/assets/js/12.85fd4e46.js"><link rel="prefetch" href="/assets/js/13.2541c587.js"><link rel="prefetch" href="/assets/js/14.a4ea9f6f.js"><link rel="prefetch" href="/assets/js/15.d3a97a3d.js"><link rel="prefetch" href="/assets/js/16.0d1af2a6.js"><link rel="prefetch" href="/assets/js/17.a3b32e45.js"><link rel="prefetch" href="/assets/js/18.0d9c767e.js"><link rel="prefetch" href="/assets/js/19.40c2dba7.js"><link rel="prefetch" href="/assets/js/20.581db0b9.js"><link rel="prefetch" href="/assets/js/21.69e7b4f8.js"><link rel="prefetch" href="/assets/js/22.3eb7eff8.js"><link rel="prefetch" href="/assets/js/23.8641f080.js"><link rel="prefetch" href="/assets/js/24.50316358.js"><link rel="prefetch" href="/assets/js/25.f4473517.js"><link rel="prefetch" href="/assets/js/26.a7330b7a.js"><link rel="prefetch" href="/assets/js/27.d7ebf121.js"><link rel="prefetch" href="/assets/js/28.17a892cf.js"><link rel="prefetch" href="/assets/js/3.a2e54aa3.js"><link rel="prefetch" href="/assets/js/30.77606581.js"><link rel="prefetch" href="/assets/js/31.2d23d33b.js"><link rel="prefetch" href="/assets/js/32.6f81889e.js"><link rel="prefetch" href="/assets/js/33.034df962.js"><link rel="prefetch" href="/assets/js/34.304c20d8.js"><link rel="prefetch" href="/assets/js/35.e6a394e7.js"><link rel="prefetch" href="/assets/js/36.fc4ad0fd.js"><link rel="prefetch" href="/assets/js/37.e4399371.js"><link rel="prefetch" href="/assets/js/38.11ad7943.js"><link rel="prefetch" href="/assets/js/39.f9af7faf.js"><link rel="prefetch" href="/assets/js/4.3caca420.js"><link rel="prefetch" href="/assets/js/40.f2900077.js"><link rel="prefetch" href="/assets/js/41.16687e70.js"><link rel="prefetch" href="/assets/js/42.6d76d5ed.js"><link rel="prefetch" href="/assets/js/43.d73917b8.js"><link rel="prefetch" href="/assets/js/44.8de10bef.js"><link rel="prefetch" href="/assets/js/45.bd1918d3.js"><link rel="prefetch" href="/assets/js/46.2f74e238.js"><link rel="prefetch" href="/assets/js/47.1e441e7a.js"><link rel="prefetch" href="/assets/js/48.0f46f83f.js"><link rel="prefetch" href="/assets/js/49.33615a95.js"><link rel="prefetch" href="/assets/js/5.f01ebfcb.js"><link rel="prefetch" href="/assets/js/50.bfb363e5.js"><link rel="prefetch" href="/assets/js/51.40e95d3b.js"><link rel="prefetch" href="/assets/js/52.c3d5330a.js"><link rel="prefetch" href="/assets/js/53.d2a767ec.js"><link rel="prefetch" href="/assets/js/54.aef594f5.js"><link rel="prefetch" href="/assets/js/55.93d2682c.js"><link rel="prefetch" href="/assets/js/56.13ad44a5.js"><link rel="prefetch" href="/assets/js/57.a82e7dd5.js"><link rel="prefetch" href="/assets/js/58.5b469ef3.js"><link rel="prefetch" href="/assets/js/59.1de1f331.js"><link rel="prefetch" href="/assets/js/6.a1b3829f.js"><link rel="prefetch" href="/assets/js/60.b9ec3fc3.js"><link rel="prefetch" href="/assets/js/61.73524b91.js"><link rel="prefetch" href="/assets/js/62.c3a424fd.js"><link rel="prefetch" href="/assets/js/63.05ad037b.js"><link rel="prefetch" href="/assets/js/64.0bb07fd6.js"><link rel="prefetch" href="/assets/js/65.7126cf00.js"><link rel="prefetch" href="/assets/js/66.8db6799d.js"><link rel="prefetch" href="/assets/js/67.1edb235e.js"><link rel="prefetch" href="/assets/js/68.15bff8eb.js"><link rel="prefetch" href="/assets/js/69.6fe4c206.js"><link rel="prefetch" href="/assets/js/7.986123ae.js"><link rel="prefetch" href="/assets/js/8.eaf297f8.js"><link rel="prefetch" href="/assets/js/9.ad4f296e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7dc41318.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zh/" class="home-link router-link-active"><!----> <span class="site-name">Code Docs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zh/network.html#tcp" class="sidebar-link">TCP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zh/network.html#tcp标志位" class="sidebar-link">TCP标志位</a></li><li class="sidebar-sub-header"><a href="/zh/network.html#tcp状态" class="sidebar-link">TCP状态</a></li><li class="sidebar-sub-header"><a href="/zh/network.html#tcp窗口" class="sidebar-link">TCP窗口</a></li><li class="sidebar-sub-header"><a href="/zh/network.html#建立连接" class="sidebar-link">建立连接</a></li><li class="sidebar-sub-header"><a href="/zh/network.html#关闭连接" class="sidebar-link">关闭连接</a></li><li class="sidebar-sub-header"><a href="/zh/network.html#time-wait" class="sidebar-link">TIME_WAIT</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="网络"><a href="#网络" class="header-anchor">#</a> 网络</h1> <h2 id="tcp"><a href="#tcp" class="header-anchor">#</a> TCP</h2> <h3 id="tcp标志位"><a href="#tcp标志位" class="header-anchor">#</a> TCP标志位</h3> <p>位码即TCP标志位。</p> <table><thead><tr><th>标示</th> <th>描述</th></tr></thead> <tbody><tr><td>SYN</td> <td>Synchronous 建立联机</td></tr> <tr><td>ACK</td> <td>Acknowledgement 确认</td></tr> <tr><td>PSH</td> <td>Push 传送</td></tr> <tr><td>FIN</td> <td>Finish 结束</td></tr> <tr><td>RST</td> <td>Reset 重置</td></tr> <tr><td>URG</td> <td>Urgent 紧急</td></tr> <tr><td>Sequence number</td> <td>顺序号码</td></tr> <tr><td>Acknowledge number</td> <td>确认号码</td></tr></tbody></table> <h3 id="tcp状态"><a href="#tcp状态" class="header-anchor">#</a> TCP状态</h3> <table><thead><tr><th>状态</th> <th>描述</th></tr></thead> <tbody><tr><td>CLOSED</td> <td>初始状态，表示没有任何连接。</td></tr> <tr><td>LISTEN</td> <td>Server端的某个Socket正在监听来自远方的TCP端口的连接请求。</td></tr> <tr><td>SYN_SENT</td> <td>发送连接请求后等待确认信息。当客户端Socket进行Connect连接时，会首先发送SYN包，随即进入SYN_SENT状态，然后等待Server端发送三次握手中的第2个包。</td></tr> <tr><td>SYN_RECEIVED</td> <td>收到一个连接请求后回送确认信息和对等的连接请求，然后等待确认信息。通常是建立TCP连接的三次握手过程中的一个中间状态，表示Server端的Socket接收到来自Client的SYN包，并作出回应。</td></tr> <tr><td>ESTABLISHED</td> <td>表示连接已经建立，可以进行数据传输。</td></tr> <tr><td>FIN_WAIT_1</td> <td>主动关闭连接的一方等待对方返回 <code>ACK</code> 包。若Socket在 <code>ESTABLISHED</code> 状态下主动关闭连接并向对方发送 <code>FIN</code> 包（表示己方不再有数据需要发送），则进入 <code>FIN_WAIT_1</code> 状态，等待对方返回 <code>ACK</code> 包，此后还能读取数据，但不能发送数据。在正常情况下，无论对方处于何种状态，都应该马上返回 <code>ACK</code> 包，所以 <code>FIN_WAIT_1</code> 状态一般很难见到。</td></tr> <tr><td>FIN_WAIT_2</td> <td>主动关闭连接的一方收到对方返回的 <code>ACK</code> 包后，等待对方发送 <code>FIN</code> 包。处于 <code>FIN_WAIT_1</code> 状态下的Socket收到了对方返回的 <code>ACK</code> 包后，便进入 <code>FIN_WAIT_2</code> 状态。由于 <code>FIN_WAIT_2</code> 状态下的Socket需要等待对方发送的 <code>FIN</code> 包，所有常常可以看到。若在 <code>FIN_WAIT_1</code> 状态下收到对方发送的同时带有 <code>FIN</code> 和 <code>ACK</code> 的包时，则直接进入 <code>TIME_WAIT</code> 状态，无须经过 <code>FIN_WAIT_2</code> 状态。</td></tr> <tr><td>CLOSE_WAIT</td> <td>表示被动关闭连接的一方在等待关闭连接。当收到对方发送的FIN包后（表示对方不再有数据需要发送），相应的返回ACK包，然后进入CLOSE_WAIT状态。在该状态下，若己方还有数据未发送，则可以继续向对方进行发送，但不能再读取数据，直到数据发送完毕。</td></tr> <tr><td>CLOSING</td> <td>比较罕见的例外状态。正常情况下，发送FIN包后应该先收到（或同时收到）对方的ACK包，再收到对方的FIN包，而CLOSING状态表示发送FIN包后并没有收到对方的ACK包，却已收到了对方的FIN包。有两种情况可能导致这种状态：其一，如果双方几乎在同时关闭连接，那么就可能出现双方同时发送FIN包的情况；其二，如果ACK包丢失而对方的FIN包很快发出，也会出现FIN先于ACK到达。</td></tr> <tr><td>LAST_ACK</td> <td>被动关闭连接的一方在CLOSE_WAIT状态下完成数据的发送后便可向对方发送FIN包（表示己方不再有数据需要发送），然后等待对方返回ACK包。收到ACK包后便回到CLOSED状态，释放网络资源。</td></tr> <tr><td>TIME_WAIT</td> <td>主动关闭连接的一方收到对方发送的FIN包后返回ACK包（表示对方也不再有数据需要发送，此后不能再读取或发送数据），然后等待足够长的时间（2MSL）以确保对方接收到ACK包（考虑到丢失ACK包的可能和迷路重复数据包的影响），最后回到CLOSED状态，释放网络资源。</td></tr></tbody></table> <h3 id="tcp窗口"><a href="#tcp窗口" class="header-anchor">#</a> TCP窗口</h3> <p>TCP使用窗口机制进行流量控制。</p> <p>连接建立时，各端分配一块 <code>缓冲区</code> 用来存储接收的数据，并将 <code>缓冲区</code> 的尺寸发送给另一端。接收方发送的确认信息中包含了自己剩余的缓冲区尺寸，剩余缓冲区空间的数量叫做 <code>窗口</code>。</p> <h3 id="建立连接"><a href="#建立连接" class="header-anchor">#</a> 建立连接</h3> <p>TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。</p> <p><strong>建立连接流程</strong></p> <ul><li><ol><li>第一次握手：客户端发送 <code>SYN</code> 包（SYN=j）到服务端，并进入 <code>SYN_SENT</code> 状态，等待服务端确认。</li></ol></li> <li><ol start="2"><li>第二次握手：服务端收到 <code>SYN</code> 包，必须确认客户A的 <code>SYN</code>（ACK=j+1），同时自己也发送一个 <code>SYN</code> 包（SYN=k），即 <code>SYN+ACK</code> 包，此时服务端由 <code>LISTEN</code> 进入 <code>SYN_RECEIVED</code> 状态。</li></ol></li> <li><ol start="3"><li>第三次握手：客户端收到服务端的 <code>SYN＋ACK</code> 包，向服务端发送确认包 <code>ACK</code>（ACK=k+1），此包发送完毕，客户端和服务端进入 <code>ESTABLISHED</code> 状态，完成三次握手。</li></ol></li></ul> <p>完成三次握手，客户端与服务端开始传送数据。</p> <h3 id="关闭连接"><a href="#关闭连接" class="header-anchor">#</a> 关闭连接</h3> <p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。</p> <p><strong>关闭连接流程</strong></p> <p>TCP采用四次握手关闭连接。</p> <ul><li><ol><li>客户端发送一个 <code>FIN</code>，用来关闭客户端到服务端的数据传送。 此时客户端进入 <code>FIN_WAIT_1</code> 状态。</li></ol></li> <li><ol start="2"><li>服务端收到这个 <code>FIN</code>，它发回一个 <code>ACK</code>，确认序号为收到的序号加1。此时服务端进入 <code>CLOSE_WAIT</code> 状态。客户端收到服务端返回的 <code>ACK</code> 包后进入 <code>FIN_WAIT_2</code> 状态，等待服务端发送 <code>FIN</code> 包。</li></ol></li> <li><ol start="3"><li>服务端完成数据的发送后，将 <code>FIN</code> 包发送给客户端，然后进入 <code>LAST_ACK</code> 状态，等待客户端返回 <code>ACK</code> 包，此后服务端既不能读取数据，也不能发送数据。</li></ol></li> <li><ol start="4"><li>客户端收到 <code>FIN</code> 包后向服务端发送 <code>ACK</code> 包，然后进入 <code>TIME_WAIT</code> 状态，接着等待足够长的时间（2MSL）以确保服务端接收到 <code>ACK</code> 包，最后回到 <code>CLOSED</code> 状态，释放网络资源。服务端收到客户端返回的 <code>ACK</code> 包后便回到 <code>CLOSED</code> 状态，释放网络资源。</li></ol></li></ul> <h3 id="time-wait"><a href="#time-wait" class="header-anchor">#</a> TIME_WAIT</h3> <p>主动关闭连接的一方在发送最后一个 <code>ACK</code> 包后，无论对方是否收到都会进入 <code>TIME_WAIT</code> 状态，等待2MSL的时间，然后才能释放网络资源。MSL就是Maximum Segment Lifetime（数据包的最大生命周期），是一个数据包能在互联网上生存的最长时间，若超过这个时间则该数据包将会消失在网络中。操作系统通常会将2MSL设为4分钟，最低不少于30秒，因而 <code>TIME_WAIT</code> 状态一般维持在30秒至4分钟。</p> <p><strong>TIME_WAIT状态的存在主要有两个原因</strong></p> <ul><li><p>可靠地实现TCP全双工连接的终止。在关TCP闭连接时，最后的ACK包是由主动关闭方发出的，如果这个 <code>ACK</code> 包丢失，则被动关闭方将重发 <code>FIN</code> 包，因此主动方必须维护状态信息，以允许它重发这个 <code>ACK</code> 包。如果不维持这个状态信息，那么主动方将回到 <code>CLOSED</code> 状态，并对被动方重发的 <code>FIN</code> 包响应 <code>RST</code> 包，而被动关闭方将此包解释成一个错误（在Java中会抛出connection reset的SocketException)。因而，要实现TCP全双工连接的正常终止，必须能够处理四次握手协议中任意一个包丢失的情况，主动关闭方必须维持状态信息进入 <code>TIME_WAIT</code> 状态。</p></li> <li><p>确保迷路重复数据包在网络中消失，防止上一次连接中的包迷路后重新出现，影响新连接。TCP数据包可能由于路由器异常而迷路，在迷路期间，数据包发送方可能因超时而重发这个包，迷路的数据包在路由器恢复后也会被送到目的地，这个迷路的数据包就称为Lost Duplicate。在关闭一个TCP连接后，如果马上使用相同的IP地址和端口建立新的TCP连接，那么有可能出现前一个连接的迷路重复数据包在前一个连接关闭后再次出现，影响新建立的连接。为了避免这一情况，TCP协议不允许使用处于 <code>TIME_WAIT</code> 状态的连接的IP和端口启动一个新连接，只有经过2MSL的时间，确保上一次连接中所有的迷路重复数据包都已消失在网络中，才能安全地建立新连接。
　　
对于客户端而言，每个连接都需要占用一个端口，而系统允许的可用端口数不足65000个（这也是在TCP参数优化后才能达到）。因此，如果客户端发起过多的连接并主动关闭（假设没有重用端口或者连接多个服务端），就会有大量的连接在关闭后处于 <code>TIME_WAIT</code> 状态，等待2MSL的时间后才能释放网络资源（包括端口），于是客户端会由于缺少可用端口而无法新建连接。</p></li></ul> <p>对服务端而言（特别是处理高并发短连接的服务端），服务端端与客户端建立的连接是使用同一个端口的，即监听的端口，每个连接通过一个五元组区分，包括源IP地址、源端口、传输层协议号、目的IP地址、目的端口，因而在理论上，服务端不受系统端口数的限制。但是，服务端对每个端口上的连接数是有限制的，它要使用哈希表记录端口上的每个连接，并受到文件描述符的最大打开数的限制。所以，如果服务端主动关闭连接，同样会有大量的连接在关闭后处于 <code>TIME_WAIT</code> 状态，等待2MSL的时间后才能释放网络资源（包括哈希表上的连接记录和文件描述符），于是服务端会由于达到哈希表和文件描述符的限制而无法接受新连接，造成性能的急剧下滑，性能曲线会持续产生严重的波动。</p> <p>对于这种情况，有三种应对方式：</p> <ol><li>试图让客户端主动关闭连接，由于每个客户端的并发量都比较低，因而不会产生性能瓶颈。</li> <li>优化服务端的系统TCP参数，使其网络资源的最大值、消耗速度和恢复速度达到平衡。</li> <li>改写TCP协议，重新实现底层代码，不过该方式难度很大，而且系统的稳定性和安全性可能受到影响。</li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次编辑时间:</span> <span class="time">2019/10/25 下午2:58:15</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f88ae1a5.js" defer></script><script src="/assets/js/2.4be379b3.js" defer></script><script src="/assets/js/29.36c60ab2.js" defer></script>
  </body>
</html>
